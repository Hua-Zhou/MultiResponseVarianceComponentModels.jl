var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [MultiResponseVarianceComponentModels]","category":"page"},{"location":"api/#MultiResponseVarianceComponentModels.MultiResponseVarianceComponentModels","page":"API","title":"MultiResponseVarianceComponentModels.MultiResponseVarianceComponentModels","text":"MultiResponseVarianceComponentModels.jl or MRVCModels.jl permits maximum likelihood (ML) and residual maximum likelihood (REML) estimation as well as inference for multivariate response variance components linear mixed models.\n\n\n\n\n\n","category":"module"},{"location":"api/#MultiResponseVarianceComponentModels.MRVCModel-Union{Tuple{T}, Tuple{Union{AbstractMatrix{T}, AbstractArray{Union{Missing, T}, 2}}, Union{Nothing, AbstractMatrix{T}}, Vector{<:AbstractMatrix{T}}}} where T<:Union{Float32, Float64}","page":"API","title":"MultiResponseVarianceComponentModels.MRVCModel","text":"MRVCModel(Y, X, V)\n\nCreate a new MRVCModel instance from response matrix Y, predictor matrix X, and kernel matrices V.\n\nPositional arguments\n\nY::AbstractVecOrMat                                : response matrix\nX::Union{Nothing, AbstractVecOrMat}                : predictor matrix\nV::Union{AbstractMatrix, Vector{<:AbstractMatrix}} : kernel matrices\n\nKeyword arguments\n\nse::Bool   : calculate standard errors. Default is true.\nreml::Bool : REML estimation instead of ML estimation. Default is false.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiResponseVarianceComponentModels.fisher_B!-Union{Tuple{MRVCModel{T}}, Tuple{T}} where T<:Union{Float32, Float64}","page":"API","title":"MultiResponseVarianceComponentModels.fisher_B!","text":"fisher_B!(model::MRVCModel)\n\nCompute the sampling variance-covariance of regression coefficients model.B,  assuming inverse of covariance matrix model.Ω is available at model.storage_nd_nd.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiResponseVarianceComponentModels.fisher_Σ!-Union{Tuple{MRVCModel{T}}, Tuple{T}} where T<:Union{Float32, Float64}","page":"API","title":"MultiResponseVarianceComponentModels.fisher_Σ!","text":"fisher_Σ!(model::MRVCModel)\n\nCompute the sampling variance-covariance of variance component estimates model.Σ,  assuming inverse of covariance matrix model.Ω is available at model.storage_nd_nd.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiResponseVarianceComponentModels.fit!-Union{Tuple{MRVCModel{T}}, Tuple{T}} where T<:Union{Float32, Float64}","page":"API","title":"MultiResponseVarianceComponentModels.fit!","text":"fit!(model::MRVCModel)\n\nFit a multivariate response variance components model by MM or EM algorithm.\n\nKeyword arguments\n\nmaxiter::Integer : maximum number of iterations. Default is 1000.\nreltol::Real     : relative tolerance for convergence. Default is 1e-6.\nverbose::Bool    : display algorithmic information. Default is true.\ninit::Symbol     : initialization strategy. :default initialize by least squares.   :user uses user supplied value at model.B and model.Σ.\nalgo::Symbol     : optimization algorithm. :MM (default) or EM.\nlog::Bool        : record iterate history or not. Defaut is false.\n\nOutput\n\nhistory          : iterate history.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiResponseVarianceComponentModels.h2-Union{Tuple{MRVCModel{T}}, Tuple{T}} where T<:Union{Float32, Float64}","page":"API","title":"MultiResponseVarianceComponentModels.h2","text":"h2(model::MRVCModel)\n\nCalculate heritability estimates and their standard errors, assuming that all variance components  capture genetic effects except the last term. Also return total heritability from sum of individual  contributions and its standard error.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiResponseVarianceComponentModels.kron_axpy!-Union{Tuple{T}, Tuple{AbstractVecOrMat{T}, AbstractVecOrMat{T}, AbstractVecOrMat{T}}} where T<:Real","page":"API","title":"MultiResponseVarianceComponentModels.kron_axpy!","text":"kron_axpy!(A, X, Y)\n\nOverwrite Y with A ⊗ X + Y. Same as Y += kron(A, X), but more memory efficient.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiResponseVarianceComponentModels.kron_reduction!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, Bool}} where T<:Real","page":"API","title":"MultiResponseVarianceComponentModels.kron_reduction!","text":"kron_reduction!(A, B, C; sym = false)\n\nOverwrite C with the derivative of tr(A' (X ⊗ B)) wrt X. C[i, j] = dot(Aij, B), where Aij is the (i , j) block of A. sym = true  indicates A and B are symmetric.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiResponseVarianceComponentModels.loglikelihood!-Union{Tuple{MRVCModel{T}}, Tuple{T}} where T<:Union{Float32, Float64}","page":"API","title":"MultiResponseVarianceComponentModels.loglikelihood!","text":"loglikelihood!(model::MRVCModel)\n\nOverwrite model.storage_nd_nd by inverse of the covariance  matrix model.Ω, overwrite model.storage_nd by U' \\ vec(model.R), and  return the log-likelihood. Assume model.Ω and model.R are  already updated according to model.Σ and model.B.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiResponseVarianceComponentModels.loglikelihood_miss!-Union{Tuple{MRVCModel{T}}, Tuple{T}} where T<:Union{Float32, Float64}","page":"API","title":"MultiResponseVarianceComponentModels.loglikelihood_miss!","text":"loglikelihood_miss!(model::MRVCModel)\n\nOverwrite model.storage_nd_nd by inverse of the covariance matrix model.Ω,  overwrite model.storage_nd by U' \\ vec(model.R), overwrite model.storage_n_miss_n_miss_1 by conditional variance, and return the  surrogate Q-function of log-likelihood. Assume model.Ω and model.R are already  updated according to model.Σ and model.B.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiResponseVarianceComponentModels.lrt-Tuple{MRVCModel, MRVCModel}","page":"API","title":"MultiResponseVarianceComponentModels.lrt","text":"lrt(model1::MRVCModel, model0::MRVCModel)\n\nPerform a variation of the likelihood ratio test for univariate variance components models as in  Molenberghs and Verbeke 2007 with model1 and model0 being the full and nested models, respectively.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiResponseVarianceComponentModels.permute-Union{Tuple{AbstractArray{Union{Missing, T}, 2}}, Tuple{T}} where T<:Union{Float32, Float64}","page":"API","title":"MultiResponseVarianceComponentModels.permute","text":"permute(Y::AbstractVecOrMat)\n\nReturn permutation P such that vec(Y)[P] rearranges vec(Y) with missing values  spliced after non-missing values. Also return inverse permutation invP such that vec(Y)[P][invP] = vec(Y).\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiResponseVarianceComponentModels.rg-Union{Tuple{MRVCModel{T}}, Tuple{T}} where T<:Union{Float32, Float64}","page":"API","title":"MultiResponseVarianceComponentModels.rg","text":"rg(model::MRVCModel)\n\nCalculate genetic/residual correlation estimates and their standard errors.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiResponseVarianceComponentModels.update_B!-Union{Tuple{MRVCModel{T}}, Tuple{T}} where T<:Union{Float32, Float64}","page":"API","title":"MultiResponseVarianceComponentModels.update_B!","text":"update_B!(model::MRVCModel)\n\nUpdate the regression coefficients model.B, assuming inverse of  covariance matrix model.Ω is available at model.storage_nd_nd.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiResponseVarianceComponentModels.update_B_miss!-Union{Tuple{MRVCModel{T}}, Tuple{T}} where T<:Union{Float32, Float64}","page":"API","title":"MultiResponseVarianceComponentModels.update_B_miss!","text":"update_B_miss!(model::MRVCModel)\n\nUpdate the regression coefficients model.B, assuming inverse of  covariance matrix model.Ω is available at model.storage_nd_nd and conditional covariance model.storage_n_miss_n_obs_1 precomputed.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiResponseVarianceComponentModels.update_Γk!-Union{Tuple{T}, Tuple{MRVCModel{T}, Integer}} where T<:Union{Float32, Float64}","page":"API","title":"MultiResponseVarianceComponentModels.update_Γk!","text":"update_Γk!(model, k)\n\nUpdate the parameters model.Γ[k] and model.Ψ[:,k] assuming a diagonal plus low rank structure for model.Σ[k]. Assumes covariance matrix model.Ω is  available at model.storage_nd_nd and model.Ω⁻¹R precomputed.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiResponseVarianceComponentModels.update_Σ!-Union{Tuple{MRVCModel{T}}, Tuple{T}} where T<:Union{Float32, Float64}","page":"API","title":"MultiResponseVarianceComponentModels.update_Σ!","text":"update_Σ!(model::MRVCModel)\n\nUpdate the variance component parameters model.Σ, assuming inverse of  covariance matrix model.Ω is available at model.storage_nd_nd. For missing response, assume conditional variance model.storage_n_miss_n_miss_1 is precomputed.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiResponseVarianceComponentModels.update_Σk!-Union{Tuple{T}, Tuple{MRVCModel{T}, Integer, Integer}} where T<:Union{Float32, Float64}","page":"API","title":"MultiResponseVarianceComponentModels.update_Σk!","text":"update_Σk!(model, k, rk)\n\nUpdate the model.Σ[k] assuming it has rank rk < d, assuming inverse of  covariance matrix model.Ω is available at model.storage_nd_nd and  model.Ω⁻¹R precomputed.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiResponseVarianceComponentModels.update_Σk!-Union{Tuple{T}, Tuple{MRVCModel{T}, Integer, Val{:EM}}} where T<:Union{Float32, Float64}","page":"API","title":"MultiResponseVarianceComponentModels.update_Σk!","text":"update_Σk!(model::MRVCModel, k, Val(:EM))\n\nEM update the model.Σ[k] assuming it has full rank d, inverse of  covariance matrix model.Ω is available at model.storage_nd_nd, and  model.Ω⁻¹R precomputed.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiResponseVarianceComponentModels.update_Σk!-Union{Tuple{T}, Tuple{MRVCModel{T}, Integer, Val{:MM}}} where T<:Union{Float32, Float64}","page":"API","title":"MultiResponseVarianceComponentModels.update_Σk!","text":"update_Σk!(model::MRVCModel, k, Val(:MM))\n\nMM update the model.Σ[k] assuming it has full rank d, inverse of  covariance matrix model.Ω is available at model.storage_nd_nd, and  model.Ω⁻¹R precomputed.\n\n\n\n\n\n","category":"method"},{"location":"api/#MultiResponseVarianceComponentModels.update_Σk_miss!-Union{Tuple{T}, Tuple{MRVCModel{T}, Integer, Val{:MM}}} where T<:Union{Float32, Float64}","page":"API","title":"MultiResponseVarianceComponentModels.update_Σk_miss!","text":"update_Σk_miss!(model::MRVCModel, k, Val(:MM))\n\nMM update the model.Σ[k] assuming it has full rank d, inverse of  covariance matrix model.Ω is available at model.storage_nd_nd, and model.Ω⁻¹R, conditional variance model.storage_n_miss_n_miss_1, and Ω⁻¹P'CPΩ⁻¹ precomputed.\n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Simulate-data","page":"Examples","title":"Simulate data","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using MultiResponseVarianceComponentModels, LinearAlgebra, Random\nRandom.seed!(6789)\nn = 1_000;  # n of observations\nd = 4;      # n of responses\np = 10;     # n of covariates\nm = 5;      # n of variance components\nX = rand(n, p);\nB = rand(p, d)\nV = [zeros(n, n) for _ in 1:m]; # kernel matrices\nΣ = [zeros(d, d) for _ in 1:m]; # variance components\nfor i in 1:m\n    Vi = randn(n, n)\n    copy!(V[i], Vi' * Vi)\n    Σi = randn(d, d)\n    copy!(Σ[i], Σi' * Σi)\nend\nΩ = zeros(n * d, n * d); # overall nd-by-nd covariance matrix Ω\nfor i = 1:m\n    Ω += kron(Σ[i], V[i])\nend\nΩchol = cholesky(Ω);\nY = X * B + reshape(Ωchol.L * randn(n * d), n, d)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"note: Note\nIn the case of heritability and genetic correlation analyses, one can use classic genetic relationship matrices (GRMs) for boldsymbolV_i's, which in turn can be constructed using SnpArrays.jl.","category":"page"},{"location":"examples/#Maximum-likelihood-estimation","page":"Examples","title":"Maximum likelihood estimation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"model = MRVCModel(Y, X, V)\n@timev fit!(model)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Then variance components and mean effects estimates can be accessed through","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"model.Σ\nmodel.B\nhcat(vec(B), vec(model.B))\nreduce(hcat, [hcat(vec(Σ[i]), vec(model.Σ[i])) for i in 1:m])","category":"page"},{"location":"examples/#Standard-errors","page":"Examples","title":"Standard errors","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Sampling variance and covariance of these estimates are","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"model.Σcov\nmodel.Bcov","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Corresponding standard error of these estimates are","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"sqrt.(diag(model.Σcov))\nsqrt.(diag(model.Bcov))","category":"page"},{"location":"examples/#Residual-maximum-likelihood-estimation","page":"Examples","title":"Residual maximum likelihood estimation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"For REML estimation, you can instead:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"model = MRVCModel(Y, X, V; reml = true)\n@timev fit!(model)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Variance components and mean effects estimates and their standard errors can be accessed through:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"model.Σ\nmodel.B_reml\nhcat(vec(B), vec(model.B_reml))\nreduce(hcat, [hcat(vec(Σ[i]), vec(model.Σ[i])) for i in 1:m])\nmodel.Σcov\nmodel.Bcov_reml\nsqrt.(diag(model.Σcov))\nsqrt.(diag(model.Bcov_reml))","category":"page"},{"location":"examples/#Estimation-only","page":"Examples","title":"Estimation only","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Calculating standard errors can be memory-consuming, so you could instead forego such calculation via:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"model = MRVCModel(Y, X, V; se = false) # or model = MRVCModel(Y, X, V; se = false, reml = true)\n@timev fit!(model)","category":"page"},{"location":"examples/#Missing-response","page":"Examples","title":"Missing response","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"You can also fit data with missing response. For example:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Y_miss = Matrix{Union{eltype(Y), Missing}}(missing, size(Y))\ncopy!(Y_miss, Y)\nY_miss[rand(1:length(Y_miss), n)] .= missing\n\nmodel = MRVCModel(Y_miss, X, V, se = false)\n@timev fit!(model)","category":"page"},{"location":"advanced/#Advanced-details","page":"Advanced details","title":"Advanced details","text":"","category":"section"},{"location":"advanced/#Estimation","page":"Advanced details","title":"Estimation","text":"","category":"section"},{"location":"advanced/","page":"Advanced details","title":"Advanced details","text":"For the MM algorithm, the updates in each iteration are","category":"page"},{"location":"advanced/","page":"Advanced details","title":"Advanced details","text":"beginaligned\ntextvec boldsymbolB^(t) = (boldsymbolI_d otimes boldsymbolX^T) boldsymbolOmega^-(t) (boldsymbolI_d otimes boldsymbolX)^-1 (boldsymbolI_d otimes boldsymbolX^T) boldsymbolOmega^-(t) textvec boldsymbolY \nboldsymbolGamma_i^(t + 1) = boldsymbolL_i^-(t)TboldsymbolL_i^(t)T(boldsymbolGamma_i^(t)boldsymbolR^(t)TboldsymbolV_iboldsymbolR^(t)boldsymbolGamma_i^(t))boldsymbolL_i^(t)^12 boldsymbolL_i^-(t)\nendaligned","category":"page"},{"location":"advanced/","page":"Advanced details","title":"Advanced details","text":"where boldsymbolOmega^(t) = sum_i=1^m boldsymbolGamma_i^(t) otimes boldsymbolV_i and boldsymbolL_i^(t) is the Cholesky factor of boldsymbolM_i^(t) = (boldsymbolI_d otimes boldsymbol1_n)^T (boldsymbol1_d boldsymbol1_d^T otimes boldsymbolV_i) odot boldsymbolOmega^-(t) (boldsymbolI_d otimes boldsymbol1_n), while boldsymbolR^(t) is the n times d matrix such that textvec boldsymbolR^(t) = boldsymbolOmega^-(t) textvec(boldsymbolY - boldsymbolX boldsymbolB^(t)).","category":"page"},{"location":"advanced/","page":"Advanced details","title":"Advanced details","text":"For the EM algorithm, the updates in each iteration are","category":"page"},{"location":"advanced/","page":"Advanced details","title":"Advanced details","text":"beginaligned\ntextvec boldsymbolB^(t) = (boldsymbolI_d otimes boldsymbolX^T) boldsymbolOmega^-(t) (boldsymbolI_d otimes boldsymbolX)^-1 (boldsymbolI_d otimes boldsymbolX^T) boldsymbolOmega^-(t) textvec boldsymbolY \nboldsymbolGamma_i^(t + 1) = frac1r_i boldsymbolGamma_i^(t)  boldsymbolR^(t)T boldsymbolV_i boldsymbolR^(t) - boldsymbolM_i^(t) boldsymbolGamma_i^(t) + boldsymbolGamma_i^(t)\nendaligned","category":"page"},{"location":"advanced/","page":"Advanced details","title":"Advanced details","text":"where r_i = textrank(boldsymbolV_i). As seen, the updates for mean effects boldsymbolB are the same for these two algorithms.","category":"page"},{"location":"advanced/","page":"Advanced details","title":"Advanced details","text":"In the setting of missing response, the adjusted MM updates in each interation are","category":"page"},{"location":"advanced/","page":"Advanced details","title":"Advanced details","text":"beginaligned\ntextvec boldsymbolB^(t) = (boldsymbolI_d otimes boldsymbolX^T) boldsymbolOmega^-(t) (boldsymbolI_d otimes boldsymbolX)^-1 (boldsymbolI_d otimes boldsymbolX^T) boldsymbolOmega^-(t) textvec boldsymbolZ^(t) \nboldsymbolGamma_i^(t + 1) = boldsymbolL_i^-(t)TboldsymbolL_i^(t)TboldsymbolGamma_i^(t)(boldsymbolR^*(t)TboldsymbolV_iboldsymbolR^*(t) + boldsymbolM_i^*(t))boldsymbolGamma_i^(t)boldsymbolL_i^(t)^12 boldsymbolL_i^-(t)\nendaligned","category":"page"},{"location":"advanced/","page":"Advanced details","title":"Advanced details","text":"where boldsymbolZ^(t) is the completed response matrix from conditional mean and boldsymbolM_i^*(t) = (boldsymbolI_d otimes boldsymbol1_n)^T (boldsymbol1_d boldsymbol1_d^T otimes boldsymbolV_i) odot (boldsymbolOmega^-(t) boldsymbolP^T boldsymbolC^(t)boldsymbolPboldsymbolOmega^-(t)) (boldsymbolI_d otimes boldsymbol1_n), while boldsymbolR^*(t) is the n times d matrix such that textvec boldsymbolR^*(t) = boldsymbolOmega^-(t) textvec(boldsymbolZ^(t) - boldsymbolX boldsymbolB^(t)). Additionally, boldsymbolP is the permutation matrix such that boldsymbolP cdot textvec(boldsymbolY) = beginbmatrix boldsymboly_textobs  boldsymboly_textmis endbmatrix, where boldsymboly_textobs and boldsymboly_textmis are vectors of observed and missing response values, respectively, in column-major order, and the block matrix boldsymbolC^(t) is boldsymbol0 except for a lower-right block consisting of conditional variance. As seen, the two MM updates for both mean effects and variance components are of similar form.","category":"page"},{"location":"advanced/#Inference","page":"Advanced details","title":"Inference","text":"","category":"section"},{"location":"advanced/","page":"Advanced details","title":"Advanced details","text":"Standard errors for our estimates are calculated using the Fisher information matrix, where","category":"page"},{"location":"advanced/","page":"Advanced details","title":"Advanced details","text":"beginaligned\ntextE left- fracpartial^2partial(textvec boldsymbolB)^T partial(textvec boldsymbolB) mathcalL right = (boldsymbolI_d otimes boldsymbolX^T) boldsymbolOmega^-1 (boldsymbolI_d otimes boldsymbolX) \ntextE left - fracpartial^2partial (textvech boldsymbolGamma_i)^T partial (textvec boldsymbolB) mathcalL right = boldsymbol0 \ntextE left - fracpartial^2partial (textvech boldsymbolGamma_j)^T partial (textvech boldsymbolGamma_i) mathcalL right = frac12 boldsymbolU_i^T (boldsymbolOmega^-1 otimes boldsymbolOmega^-1) boldsymbolU_j\nendaligned","category":"page"},{"location":"advanced/","page":"Advanced details","title":"Advanced details","text":"and boldsymbolU_i = (boldsymbolI_d otimes boldsymbolK_nd otimes boldsymbolI_n) (boldsymbolI_d^2 otimes textvec boldsymbolV_i) boldsymbolD_d. Here, boldsymbolK_nd is the nd times nd commutation matrix and boldsymbolD_d the d^2 times fracd(d+1)2 duplication matrix. textvech boldsymbolGamma_i creates an fracd(d+1)2 times 1 vector from boldsymbolGamma_i by stacking its lower triangular part.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MultiResponseVarianceComponentModels","category":"page"},{"location":"#MultiResponseVarianceComponentModels","page":"Home","title":"MultiResponseVarianceComponentModels","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MRVCModels.jl is a package for fitting and testing multivariate response variance components linear mixed models of form","category":"page"},{"location":"","page":"Home","title":"Home","text":"textvec boldsymbolY sim mathcalN(textvec(boldsymbolX boldsymbolB) sum_i=1^m boldsymbolGamma_i otimes boldsymbolV_i)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where boldsymbolY and boldsymbolX are n times d response and  n times p predictor matrices, respectively, and boldsymbolV_1 ldots boldsymbolV_m are m known n times n positive semidefinite matrices. textvec boldsymbolY creates an nd times 1 vector from boldsymbolY by stacking its columns and otimes denotes the Kronecker product. The parameters of the model include p times d mean effects boldsymbolB and d times d variance components (boldsymbolGamma_1 dots boldsymbolGamma_m), which MRVCModels.jl estimates through either minorization-maximization (MM) or expectation–maximization (EM) algorithms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nMRVCModels.jl is not suitable for biobank-scale data. We recommend using this package for datasets of size up to n cdot d approx 50000. This package can also handle data with missing response.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use MRVCModels.jl, type:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url = \"https://github.com/Hua-Zhou/MultiResponseVarianceComponentModels.jl.git\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"This documentation was built using Documenter.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Dates # hide\nprintln(\"Documentation built $(Dates.now()) with Julia $(VERSION)\") # hide","category":"page"}]
}
